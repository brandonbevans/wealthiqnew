//
//  SupabaseManager.swift
//  prime
//
//  Created on 11/17/25.
//

import Combine
import Foundation
import Supabase

/// Manager class for handling all Supabase operations
@MainActor
class SupabaseManager: ObservableObject {
  let objectWillChange = ObservableObjectPublisher()
  static let shared = SupabaseManager()

  private let client: SupabaseClient

  private init() {
    print("ðŸš€ [SupabaseManager] Initializing Supabase client...")
    
    // Initialize Supabase client with configuration
    guard Config.isConfigured else {
      fatalError(
        "Supabase configuration is missing or invalid. Please update Config.swift with your Supabase project details."
      )
    }
    
    let urlString = Config.supabaseURL
    
    guard let supabaseURL = URL(string: urlString) else {
      fatalError(
        "Supabase URL is invalid: \(urlString). Please check your SUPABASE_URL configuration."
      )
    }
    
    let anonKey = Config.supabaseAnonKey

    let options = SupabaseClientOptions(
      auth: .init(
        emitLocalSessionAsInitialSession: true
      )
    )

    self.client = SupabaseClient(
      supabaseURL: supabaseURL,
      supabaseKey: anonKey,
      options: options
    )
    print("âœ… [SupabaseManager] SupabaseClient created successfully")
  }

  // MARK: - User Profile Operations

  /// Structure matching the database schema for user data
  struct UserProfile: Codable {
    let id: Int?  // BIGSERIAL primary key from database
    let userId: UUID
    let gender: String?
    let firstName: String
    let age: Int
    let goalRecency: String?
    let primaryGoal: String
    let goalVisualization: String
    let microAction: String
    let coachingStyle: String?
    let onboardingCompleted: Bool
    let onboardingCompletedAt: Date?
    let lastCompletedStep: String?

    enum CodingKeys: String, CodingKey {
      case id
      case userId = "user_id"
      case gender
      case firstName = "first_name"
      case age
      case goalRecency = "goal_recency"
      case primaryGoal = "primary_goal"
      case goalVisualization = "goal_visualization"
      case microAction = "micro_action"
      case coachingStyle = "coaching_style"
      case onboardingCompleted = "onboarding_completed"
      case onboardingCompletedAt = "onboarding_completed_at"
      case lastCompletedStep = "last_completed_step"
    }
  }

  /// Save user onboarding data to Supabase
  func saveOnboardingData(
    gender: Gender?,
    firstName: String,
    age: Int,
    goalRecency: GoalRecency?,
    primaryGoal: String,
    goalVisualization: String,
    microAction: String,
    coachingStyle: CoachingStyle?,
    lastCompletedStep: String? = nil
  ) async throws -> UserProfile {
    // Get the current authenticated user ID
    let userId = try await getCurrentUserId()

    // Map enum values to database-friendly strings
    let genderString = gender?.rawValue.lowercased()
    let goalRecencyString = mapGoalRecencyToDatabase(goalRecency)
    let coachingStyleString = mapCoachingStyleToDatabase(coachingStyle)

    // Create user profile object
    let profile = UserProfile(
      id: nil,  // Will be auto-generated by database
      userId: userId,
      gender: genderString,
      firstName: firstName,
      age: age,
      goalRecency: goalRecencyString,
      primaryGoal: primaryGoal,
      goalVisualization: goalVisualization,
      microAction: microAction,
      coachingStyle: coachingStyleString,
      onboardingCompleted: true,
      onboardingCompletedAt: Date(),
      lastCompletedStep: lastCompletedStep
    )

    // Insert or update the user profile
    do {
      print("ðŸ“¤ Sending profile to Supabase...")
      print("  - Table: user_profiles")
      print("  - User ID: \(userId)")
      print("  - Operation: UPSERT (will create or update)")

      let response: PostgrestResponse<UserProfile> =
        try await client
        .from("user_profiles")
        .upsert(profile, onConflict: "user_id")
        .select()
        .single()
        .execute()

      print("âœ… Supabase response received - profile saved/updated")
      return response.value
    } catch {
      print("âŒ Supabase error during profile save:")
      print("  - Error: \(error)")
      print("  - Type: \(type(of: error))")
      throw error
    }
  }

  /// Fetch the current user's profile
  func fetchUserProfile() async throws -> UserProfile? {
    let userId = try await getCurrentUserId()

    // Use limit(1) instead of single() to avoid throwing error when no profile exists
    let response: PostgrestResponse<[UserProfile]> =
      try await client
      .from("user_profiles")
      .select()
      .eq("user_id", value: userId.uuidString)
      .limit(1)
      .execute()

    return response.value.first
  }

  // MARK: - Goal Operations

  struct Goal: Codable {
    let id: UUID?
    let userId: UUID
    let createdAt: Date?
    let updatedAt: Date?
    let goalText: String
    let visualizationText: String?
    let microAction: String?
    let status: String
    let completedAt: Date?
    let goalType: String?
    let targetDate: Date?
    let notes: String?

    enum CodingKeys: String, CodingKey {
      case id
      case userId = "user_id"
      case createdAt = "created_at"
      case updatedAt = "updated_at"
      case goalText = "goal_text"
      case visualizationText = "visualization_text"
      case microAction = "micro_action"
      case status
      case completedAt = "completed_at"
      case goalType = "goal_type"
      case targetDate = "target_date"
      case notes
    }
  }

  // MARK: - Session Records

  struct SessionRecord: Codable {
    let id: UUID?
    let userId: UUID
    let createdAt: Date?
    let elevenLabsConversationId: String?
    let elevenLabsAgentId: String?

    enum CodingKeys: String, CodingKey {
      case id
      case userId = "user_id"
      case createdAt = "created_at"
      case elevenLabsConversationId = "elevenlabs_conversation_id"
      case elevenLabsAgentId = "elevenlabs_agent_id"
    }
  }

  /// Upload session audio into the sessions storage bucket and return the object path.
  func uploadSessionAudio(
    data: Data,
    userId: UUID,
    sessionId: UUID,
    fileExtension: String,
    mimeType: String
  ) async throws -> String {
    let normalizedExtension = fileExtension.trimmingCharacters(in: .whitespacesAndNewlines)
    let safeExtension = normalizedExtension.isEmpty ? "mp3" : normalizedExtension
    let userFolder = userId.uuidString.lowercased()
    let objectPath = "\(userFolder)/audio/\(sessionId.uuidString)/conversation.\(safeExtension)"

    do {
      _ = try await client.storage
        .from("sessions")
        .upload(
          objectPath,
          data: data,
          options: FileOptions(contentType: mimeType, upsert: false)
        )
      return objectPath
    } catch {
      print("âŒ Failed to upload session audio: \(error)")
      throw error
    }
  }

  /// Insert a new row into the public.sessions table so we can list archived sessions later.
  func insertSessionRecord(
    sessionId: UUID,
    userId: UUID,
    conversationId: String,
    agentId: String?
  ) async throws -> SessionRecord {
    let record = SessionRecord(
      id: sessionId,
      userId: userId,
      createdAt: nil,
      elevenLabsConversationId: conversationId,
      elevenLabsAgentId: agentId
    )

    do {
      let response: PostgrestResponse<SessionRecord> =
        try await client
        .from("sessions")
        .insert(record)
        .select()
        .single()
        .execute()
      return response.value
    } catch {
      print("âŒ Failed to insert session record: \(error)")
      throw error
    }
  }

  /// Fetch an existing session record by ElevenLabs conversation ID.
  func fetchSessionRecord(conversationId: String) async throws -> SessionRecord? {
    let response: PostgrestResponse<[SessionRecord]> =
      try await client
      .from("sessions")
      .select()
      .eq("elevenlabs_conversation_id", value: conversationId)
      .limit(1)
      .execute()

    return response.value.first
  }

  /// Create a new goal for the user
  func createGoal(
    goalText: String,
    visualizationText: String? = nil,
    microAction: String? = nil,
    goalType: String? = nil,
    targetDate: Date? = nil
  ) async throws -> Goal {
    let userId = try await getCurrentUserId()

    let goal = Goal(
      id: nil,
      userId: userId,
      createdAt: nil,
      updatedAt: nil,
      goalText: goalText,
      visualizationText: visualizationText,
      microAction: microAction,
      status: "active",
      completedAt: nil,
      goalType: goalType,
      targetDate: targetDate,
      notes: nil
    )

    let response: PostgrestResponse<Goal> =
      try await client
      .from("goals")
      .insert(goal)
      .select()
      .single()
      .execute()

    return response.value
  }

  /// Fetch all goals for the current user
  func fetchUserGoals() async throws -> [Goal] {
    let userId = try await getCurrentUserId()

    let response: PostgrestResponse<[Goal]> =
      try await client
      .from("goals")
      .select()
      .eq("user_id", value: userId.uuidString)
      .order("created_at", ascending: false)
      .execute()

    return response.value
  }

  // MARK: - Authentication Helpers

  /// Sign up a new user with email and password
  func signUp(email: String, password: String) async throws {
    try await client.auth.signUp(email: email, password: password)
  }

  /// Sign in an existing user
  func signIn(email: String, password: String) async throws {
    try await client.auth.signIn(email: email, password: password)
  }

  /// Sign in with Apple ID token
  func signInWithApple(idToken: String, nonce: String) async throws {
    try await client.auth.signInWithIdToken(credentials: .init(provider: .apple, idToken: idToken, nonce: nonce))
  }

  /// Sign out the current user
  func signOut() async throws {
    do {
      try await client.auth.signOut()
      print("âœ… Supabase sign out successful")
    } catch {
      print("âš ï¸ Sign out error (will clear session anyway): \(error)")
      // Even if sign out fails, we should clear the local session
      throw error
    }
  }

  /// Force clear all session data (debug only)
  func forceClearSession() {
    // Clear Supabase client session
    Task {
      try? await client.auth.signOut(scope: .local)
    }
    print("ðŸ”„ Force cleared local session")
  }

  /// Get the current authenticated user's ID
  func getCurrentUserId() async throws -> UUID {
    do {
      let session = try await client.auth.session
      print("ðŸ” Current session:")
      print("  - User ID: \(session.user.id)")
      print("  - Email: \(session.user.email ?? "no email")")
      print("  - Expired: \(session.isExpired)")

      guard !session.isExpired else {
        print("âŒ Session is expired")
        throw SupabaseError.authenticationRequired
      }
      guard let userId = UUID(uuidString: session.user.id.uuidString) else {
        print("âŒ Could not parse user ID: \(session.user.id.uuidString)")
        throw SupabaseError.authenticationRequired
      }
      return userId
    } catch {
      print("âŒ Failed to get current user: \(error)")
      throw SupabaseError.authenticationRequired
    }
  }

  /// Check if user is authenticated
  func isAuthenticated() async -> Bool {
    do {
      let session = try await client.auth.session
      return !session.isExpired
    } catch {
      return false
    }
  }
  
  // MARK: - Debug Methods
  
  /// Test the Supabase connection (for debugging)
  func testConnection() async {
    print("ðŸ§ª [SupabaseManager] Testing connection...")
    print("   - URL: \(Config.supabaseURL)")
    
    do {
      // Try a simple health check endpoint
      let url = URL(string: "\(Config.supabaseURL)/rest/v1/")!
      print("   - Testing endpoint: \(url)")
      
      var request = URLRequest(url: url)
      request.httpMethod = "GET"
      request.setValue(Config.supabaseAnonKey, forHTTPHeaderField: "apikey")
      request.setValue("Bearer \(Config.supabaseAnonKey)", forHTTPHeaderField: "Authorization")
      
      let (data, response) = try await URLSession.shared.data(for: request)
      
      if let httpResponse = response as? HTTPURLResponse {
        print("   - Status code: \(httpResponse.statusCode)")
        print("   - Response headers: \(httpResponse.allHeaderFields)")
      }
      
      if let responseString = String(data: data, encoding: .utf8) {
        print("   - Response body: \(responseString.prefix(200))")
      }
      
      print("âœ… [SupabaseManager] Connection test successful")
    } catch {
      print("âŒ [SupabaseManager] Connection test failed:")
      print("   - Error: \(error)")
      print("   - Error type: \(type(of: error))")
      if let urlError = error as? URLError {
        print("   - URL Error code: \(urlError.code.rawValue)")
        print("   - URL Error description: \(urlError.localizedDescription)")
      }
    }
  }

  // MARK: - Helper Methods

  private func mapGoalRecencyToDatabase(_ recency: GoalRecency?) -> String? {
    switch recency {
    case .lastWeek:
      return "lastWeek"
    case .lastMonth:
      return "lastMonth"
    case .lastYear:
      return "lastYear"
    case .cantRemember:
      return "cantRemember"
    case nil:
      return nil
    }
  }

  private func mapCoachingStyleToDatabase(_ style: CoachingStyle?) -> String? {
    switch style {
    case .direct:
      return "direct"
    case .dataDriven:
      return "dataDriven"
    case .encouraging:
      return "encouraging"
    case .reflective:
      return "reflective"
    case nil:
      return nil
    }
  }
}

// MARK: - Custom Errors

enum SupabaseError: LocalizedError {
  case authenticationRequired
  case invalidConfiguration

  var errorDescription: String? {
    switch self {
    case .authenticationRequired:
      return "User must be authenticated to perform this action"
    case .invalidConfiguration:
      return "Supabase configuration is missing or invalid"
    }
  }
}
